# %%
from multi_path_base import *
%matplotlib tk
forecast_with_data=np.load('forecast_with_data.npy')
# %%
interpolation_points=1000
x = np.arange(1,72+1,1)

y = forecast_with_data[80,:,1] #X[j,:]
tck = interpolate.splrep(x, y, s=0)

xnew_global=np.linspace(1,72,interpolation_points)
p = interpolate.splev(xnew_global, tck, der=0)

N=len(p)
dt=1
M_test=1000
#real_1 = real(15, 0.1)
real_1 = real(0.15878588, 1.40043092)
#real_1 = real(1e-1,1e-5)

disct_temp = disct(N,dt,M_test)
# %%
N=disct_temp.N
dt=disct_temp.dt
M=disct_temp.M
X0=p[0]

theta=real_1.mu
alpha=real_1.sigma
issue_counter=0
X=np.zeros((M,N))
max_tries=100
i=0
j=0
while j < M:
    X[j,0]=X0
    a=0
    b=0
    dW=np.sqrt(dN)*np.random.normal(0, 1, N)
    i=0
    while i<N-1:
        try:
            try_count=0
            X[j,0]=X0

            b=  2*alpha*theta*p[i]*(1-p[i])*X[j,i]*(1-X[j,i])
            a= - theta*(X[j,i]-p[i]) + (p[i+1]-p[i])/dN

            X[j,i+1]= X[j,i] + a*dN+ np.sqrt(b)*dW[i]
            #print(X[j,i+1])
            if (X[j,i+1]<0) or (X[j,i+1])>1:
                #print('EXCEPTION !! ')
                Z0=X[j,i+1]
                raise Exception('outside: {}'.format(X[j,i+1]) )
            #print('here')
        except:
            #print('issue with ', X[j,i+1])
            interpolation_count=0
            Z_init=X[j,i]
            Z_sol=X[j,i+1]
            while Z_sol<0 or Z_sol>1:
                #print('Solving Expection')
                try_count += 1
                interpolation_count+=1

                #print('Try # : ' +str(try_count))

                interpolation_points=10*interpolation_count
                x = np.array((0,1))
                y = np.array(( p[i-1] , p[i] ))
                f = interpolate.interp1d(x, y)
                xnew=np.linspace(0,1,interpolation_points)
                p_inside = f(xnew)

                dN_in=1/(N+ interpolation_points)
                dW_inner=np.sqrt(dN_in)*np.random.normal(0, 1, interpolation_points)

                Z=np.zeros((interpolation_points))
                Z[0]=Z_init
                for  k in range(0,interpolation_points-1):
                    b=  2*alpha*theta*p_inside[k]*(1-p_inside[k])*Z[k]*(1-Z[k])
                    a= - theta*(Z[k]-p_inside[k]) + (p_inside[k+1]-p_inside[k])/dN_in
                    #print(b)
                    Z[k+1]= Z[k] + a*dN_in+ np.sqrt(b)*dW_inner[k]

                    #print(Z[k+1])
                if np.isnan(Z[k+1])==False:
                    Z_sol = Z[k+1]
                    #print('achieved ',Z_sol)
            pass
            X[j,i+1]= Z_sol
            #print('achieved ',Z_sol)
            issue_counter+=1
            i+=1
            if try_count >= max_tries:
                raise Exception("Unable to generate after %s tries" % max_tries)
        else:
            i+=1
    j+=1
print(issue_counter, ' issues resolved')
# %%
#plt.plot(X[0,:])
fig = plt.figure(0)
fig.clf()

plt.xlim(0, 72)
plt.ylim(0, 1)
for j in range(0,15):
    plt.plot(xnew_global,X[j,:], 'k-')
plt.plot(xnew_global,X[j,:], 'k-', label='simulated forecast')
plt.plot(xnew_global,p, 'r-', label='forecast')
plt.title('Simulated X paths using adaptive $\\Delta t$ ',fontsize=24)
plt.xlabel('Time [hr]')
plt.ylabel('Power')
plt.legend()
# %%
